<!DOCTYPE html>
<html>
  <head>
    <!-- requirejs config -->
    <script>
      var require = {
        baseUrl : '../', 
      };
    </script>
    <!-- requirejs -->
    <script type="text/javascript" src="../../lib/require.js"></script>
    <!--  main -->
    <script text="javascript">

      require(['sequencing/axis', 'util/interval', 'util/cue'], function (Axis, Interval, Cue) {

        var timeit = function (func, name) {
          let t0 = performance.now();
          let result = func();
          let t1 = performance.now();
          console.log(name, t1-t0);
          return result;
        };

        var make_sorted_ints = function (size, options) {
          options = options || {};
          offset = options['offset'] || 0;
          let numbers = [];
          for (let i=0; i<size; i++) {
            numbers.push(Math.floor(i+offset));
          }
          return numbers;
        };

        var make_sorted_floats = function (size, options) {
          options = options || {};
          offset = options['offset'] || 0;
          let numbers = [];
          for (let i=0; i<size; i++) {
            numbers.push(i+offset);
          }
          return numbers;
        };

        var make_random_ints = function (size, options) {
          options = options || {};
          scale = options['scale'] || 1;
          offset = options['offset'] || 0;
          return Array.from({length: size}, () => Math.floor(Math.random() * scale + offset));
        };

        var make_random_floats = function (size, options) {
          options = options || {};
          scale = options['scale'] || 1;
          offset = options['offset'] || 0;
          return Array.from({length: size}, () => Math.random() * scale + offset);
        };


        var make_singular_cues = function (size, scale) {
          let numbers = Array.from({length: size}, () => Math.floor(Math.random() * scale));
          return numbers.map(function (n) {
            return {key: "key " + n.toString(), interval: new Interval(n), data: "data_" + n}; 
          });
        };

        var make_remove_cues = function (size, scale) {
          let numbers = Array.from({length: size}, () => Math.floor(Math.random() * scale));
          return numbers.map(function (n) {
            return {key: "key " + n.toString()};
          });
        };

        var make_singular_cues_sorted_unique = function (size) {
          let numbers = [];
          for (let i=0; i<size; i++) {
            numbers.push(i);
          }
          return numbers.map(function (n) {
            return {key: n.toString(), interval: new Interval(n, n+1), data: "data_" + n};
          });
        };

        var make_cues_from_numbers = function (numbers, options) {
          options = options || {};
          let op = options['op'] || "add";
          return numbers.map(function (n) {
            if (op == "remove") {
              return {key: n.toString()};
            } else {
              return {key: n.toString(), interval: new Interval(n, n+1), data: "data_" + n};
            }
          });
        };



        var test_basic = function () {
          console.log("insert");
          let cues = make_singular_cues(10, 10);
          console.log(cues.map(x=>x.key));
          let sc = new Axis();
          let items = sc.update(cues);
          console.log(items);
          console.log("keyMap ", sc.keyMap.size);
          console.log("array ", sc.pointIndex.array.length);

          console.log("remove")
          let cues2 = make_remove_cues(10, 10);
          console.log(cues2.map(x=>x.key));
          items = sc.update(cues2);
          console.log(items);
          console.log("keyMap ", sc.keyMap.size);
          console.log("array ", sc.pointIndex.array.length);
        };

        var test_bigbatch = function (size) {
          //let cues = make_singular_cues_sorted_unique(size);
          let cues = make_singular_cues(size, size/2);
          let sc = new Axis();
          timeit(function () {
            sc.update(cues);
          }, "add bigbatch " + size);

          // add more
          cues = make_singular_cues(size, size/2);
          timeit(function () {
            sc.update(cues);
          }, "add bigbatch " + size);

        };


        


        var test_batch_collapsing = function () {
          let sc = new Axis();
          let cue, item;

          cue_1 = {key: "one", interval: new Interval(1) , data:"one"};
          item = sc.update([cue_1])[0];
          console.log(item);

          let cues = [
            {key: "two", interval: new Interval(1) , data:"one"},
            {key: "two"},
            {key: "two", interval: new Interval(2) , data:"one"},
          ]
          items = sc.update(cues);
          items.forEach(x=>{console.log(x)});
          console.log(sc.pointIndex.array);
          console.log(...sc.keyMap.values());
          console.log(sc.pointMap.size);


          // check that old value is defined by cue_1
          cues = [
            {key: "one", interval: new Interval(3) , data:"one"},
            {key: "one"},
            {key: "one", interval: new Interval(4) , data:"one"},
          ]
          items = sc.update(cues);
          items.forEach(x=>{console.log(x)});
          console.log(sc.pointIndex.array);
          console.log(...sc.keyMap.values());
          console.log(sc.pointMap.size);

        };


        var test_getCuePointsCoveredByInterval = function () {
          let sc = new Axis();

          let cues = [];
          for (let i=0; i<100; i++) {
            cues.push({key: i.toString(), interval: new Interval(i)});
          }
          for (let i=0; i<100; i++) {
            cues.push({key: "jalla" + i.toString(), interval: new Interval(i)});
          }
          cues.reverse();
          sc.update(cues);

          let interval = new Interval(3.9,18);
          let pointIterable = sc.getCuePointsCoveredByInterval(interval);

          for (let p of pointIterable) {
            console.log(p);
          }
        };


        var test_getCuesOverlappingInterval = function () {
          let sc = new Axis();

          let cues = [];
          for (let i=0; i<100; i++) {
            cues.push({key: i.toString(), interval: new Interval(i, i+1)});
          }
          /*
          for (let i=0; i<100; i++) {
            cues.push({key: "jalla" + i.toString(), interval: new Interval(i, i+1)});
          }
          */
          cues.reverse();
          sc.update(cues);

          let interval = new Interval(4, 18, true, true);
          sc.update([{
            key: "overlapping",
            interval: new Interval(1, 20)
          }]);
          let cueIterable = sc.getCuesOverlappingInterval(interval);
            
          for (let cue of cueIterable) {
            console.log(cue);
          }
        };






        var test_event = function () {
          let ax = new Axis();

          
          // change event for the entire batch
          ax.on("change", function (e) {
            console.log("onchange ", e);
          });
          

          // events event for the entire batch
          ax.on("events", function (eItemList) {
            console.log("onevents ", eItemList.length);
            for (let eItem of eItemList) {
              console.log(eItem);
            }
          });

          // update
          let cues = [];
          for (let i=0; i<100; i++) {
            cues.push({key: i.toString(), interval: new Interval(i, i+1)});
          }

          ax.update(cues)

        };


        var test_main = function () {
          let DATASIZE = 50000;
          let ax = new Axis();
          console.log(ax.keyMap.size);

          // initialise
          let numbers_1 = make_sorted_floats(DATASIZE);
          let batch_1 = make_cues_from_numbers(numbers_1);
          timeit(function () {
            ax.update(batch_1);
          }, "initialise sorted cues " + DATASIZE);
          console.log(ax.keyMap.size);

          // insert after initialise
          let numbers_2 = make_sorted_floats(DATASIZE, {offset:0.5});
          let batch_2 = make_cues_from_numbers(numbers_2);
          timeit(function () {
            ax.update(batch_2);
          }, "insert more sorted cues " + DATASIZE);
          console.log(ax.keyMap.size);

          ax.clear();
          console.log(ax.keyMap.size);

          // initialise
          let numbers_3 = make_random_floats(DATASIZE, {scale:DATASIZE});
          let batch_3 = make_cues_from_numbers(numbers_3);
          timeit(function () {
            ax.update(batch_3);
          }, "initialise random cues " + DATASIZE);
          console.log(ax.keyMap.size);

          // insert after initialise
          let numbers_4 = make_random_floats(DATASIZE, {scale:DATASIZE});
          let batch_4 = make_cues_from_numbers(numbers_4);
          timeit(function () {
            ax.update(batch_4);
          }, "insert more random cues " + DATASIZE);
          console.log(ax.keyMap.size);

          // lookup
          let interval = new Interval(DATASIZE*0.25, DATASIZE*0.75);
          let iterable, arr;
          
          timeit(function () {
            iterable = ax.getCuePointsCoveredByInterval(interval);
          }, "lookup cuepoints " + interval.toString());
          arr = timeit(function () {
            return Array.from(iterable);
          }, "iterable to array ");
          console.log(arr.length);

          timeit(function () {
            arr = ax.getCuePointsCoveredByIntervalArray(interval);
          }, "lookup cuepoints " + interval.toString());
          console.log(arr.length);


          timeit(function () {
            iterable = ax.getCuesOverlappingInterval(interval);
          }, "lookup cues " + interval.toString());
          arr = timeit(function () {
            return Array.from(iterable);
          }, "iterable to array ");
          console.log(arr.length);






          /*
          // remove
          let numbers_3 = make_random_ints(DATASIZE, DATASIZE);
          let batch_3 = make_cues_from_numbers(numbers_3, "remove");
          timeit(function () {
            sc.update(batch_3);
          }, "remove random ints " + DATASIZE);
          */

        };



        var run = function () {
          //test_basic();
          //test_bigbatch(100000);
          test_main();

          //test_batch_collapsing();
          //test_getCuePointsCoveredByInterval();
          //test_getCuesOverlappingInterval();
          //test_event();
        };

        if (document.readyState === "complete") run();
        else window.onload = run;
      });
    </script>    
  </head>
  <body>
    <h1>Test Singular Cues</h1>
  </body>
</html>